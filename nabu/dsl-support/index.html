---
layout: nabu
title: Nabu - DSL support
---
<h1>DSL support</h1>

<h2>Introduction</h2>

A Domain specific language (DSL) allows you to write code more easily for a specific domain,
for example xml, json, jpa, etc.<br/>
The DSL is a compiler feature not a language feature so it can work independently of the language
we it is used in and can define it own rules.
<br/>

<h2>Implement</h2>
To implement a DSL on or more interfaces can be implemented.

<table>
    <thead>
    <tr><th>Interface</th><th>Description</th></tr>
    </thead>
    <tbody>
    <tr><td>io.github.potjerodekool.nabu.compiler.resolve.spi.ElementResolver</td><td>Resolves elements in a DSL</td></tr>
    <tr><td>io.github.potjerodekool.nabu.compiler.transform.CodeTransformer</td><td>Transforms a DSL into Java code</td></tr>
    </tbody>
</table>

<br/>
<h2>Register implementations</h2>
Implementations of the interfaces can be registered in the plugin.xml file.

<pre class="code">
    &lt;?xml version="1.0" encoding="UTF-8" ?&gt;
    &lt;plugin&gt;
        &lt;id>io.github.potjerodekool.nabu.plugin.simple&lt;/id&gt;
    &lt;version>0.0.1&lt;/version&gt;
    &lt;description>Simple plugin for Nabu compiler&lt;/description&gt;
    &lt;extensions&gt;
        &lt;code-transformer implementationClass="io.github.potjerodekool.nabu.plugin.simple.transform.SimpleTransformer"/&gt;
        &lt;element-resolver implementationClass="io.github.potjerodekool.nabu.plugin.simple.transform.SimpleElementResolver"/&gt;
    &lt;/extensions&gt;
    &lt;/plugin&gt;
</pre>

<h2>DSL example</h2>
Take for example JPA. Writing a Predicate quickly results in hard to read code like this:

<pre class="code">
    fun findCompanyByEmployeeFirstName(employeeFirstName: String): Specification&lt;Company&gt; {
        return (c : Root&lt;Company&gt;, q: CriteriaQuery&lt;?&gt;, cb: CriteriaBuilder) -> {
            var e = (InnerJoin&lt;Company, Employee&gt;) c.employees;
            var e = c.join(Company_.employees, JoinType.INNER);
            return cb.equal(e.get(Employee_.FIRST_NAME), employeeFirstName);
        };
     }
</pre>

With a DSL you could write more readable code like this:

<pre class="code">
    fun findCompanyByEmployeeFirstName(employeeFirstName: String): Specification&lt;Company&gt; {
        return (c : Root&lt;Company&gt;, q: CriteriaQuery&lt;?&gt;, cb: CriteriaBuilder) -> {
            var e = (InnerJoin&lt;Company, Employee&gt;) c.employees;
            return e.firstName == employeeFirstName;
        };
     }
</pre>

Were a join is defined with a cast using a DSL class (InnerJoin in this example)
and access the fields of the entity directly.

The code is transformed to the code below.
As you can see the code doesn't use the static metamodel classes
since the plugin has access to the code and can check if fields exists or not.

<pre class="code">
    fun findCompanyByEmployeeFirstName(employeeFirstName: String): Specification&lt;Company&gt; {
        return (c : Root&lt;Company&gt;, q: CriteriaQuery&lt;?&gt;, cb: CriteriaBuilder) -> {
            var e = c.join("employees", JoinType.INNER);
            return cb.equal(e.get("firstName"), employeeFirstName);
        };
     }
</pre>

